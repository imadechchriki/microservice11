name: Perfect CI/CD Pipeline

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: docker.io
  IMAGE_OWNER: ${{ secrets.DOCKERHUB_USERNAME }}
  IMAGE_PREFIX: microservice11

jobs:
  # Job 1: Build et Push des images
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: auth-service
            context: backend/authentication_system/authentication_system
            dockerfile: Dockerfile
          - name: catalog-service
            context: backend/catalog-service
            dockerfile: Dockerfile
          - name: questionnaire-service
            context: backend/questionnaire-service
            dockerfile: Dockerfile
          - name: statistics-service
            context: backend/statistics-service/Statistics.API
            dockerfile: Dockerfile
          - name: api-gateway
            context: backend/api-gateway
            dockerfile: Dockerfile
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üè∑Ô∏è Generate metadata
        id: meta
        run: |
          # G√©n√©rer un tag bas√© sur le SHA court pour une meilleure lisibilit√©
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${SHORT_SHA}"
          
          # Si c'est une PR, ajouter le num√©ro de PR
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            IMAGE_TAG="pr-${{ github.event.number }}-${SHORT_SHA}"
          fi
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          
          # G√©n√©rer les tags complets
          FULL_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}"
          echo "image-name=${FULL_IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: üîß Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: üîç Verify Dockerfile exists
        run: |
          if [[ ! -f "${{ matrix.context }}/${{ matrix.dockerfile }}" ]]; then
            echo "‚ùå Dockerfile not found: ${{ matrix.context }}/${{ matrix.dockerfile }}"
            exit 1
          fi
          echo "‚úÖ Dockerfile found: ${{ matrix.context }}/${{ matrix.dockerfile }}"

      - name: üèóÔ∏è Build and push ${{ matrix.name }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.context }}/${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-latest
            ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          labels: |
            org.opencontainers.image.title=${{ matrix.name }}
            org.opencontainers.image.description=Microservice ${{ matrix.name }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          cache-from: type=registry,ref=${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-cache
          cache-to: type=registry,ref=${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-cache,mode=max

      - name: üîç Verify image was pushed
        run: |
          echo "üîç V√©rification de l'image pouss√©e..."
          docker pull ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          docker inspect ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          echo "‚úÖ Image ${{ matrix.name }} v√©rifi√©e avec succ√®s!"

  # Job 2: Validation de la configuration Docker Compose
  validate-compose:
    name: Validate Docker Compose
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup environment variables
        run: |
          echo "REGISTRY=${{ env.REGISTRY }}" >> .env
          echo "IMAGE_OWNER=${{ secrets.DOCKERHUB_USERNAME }}" >> .env
          echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" >> .env
          echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}" >> .env
          
          echo "üìã Configuration g√©n√©r√©e:"
          cat .env

      - name: ‚úÖ Validate docker-compose configuration
        run: |
          echo "üîç Validation de la configuration docker-compose..."
          docker compose config --quiet
          echo "‚úÖ Configuration docker-compose valid√©e!"

      - name: üîç Check image availability
        run: |
          echo "üîç V√©rification de la disponibilit√© des images..."
          
          services=("auth-service" "catalog-service" "questionnaire-service" "statistics-service" "api-gateway")
          
          for service in "${services[@]}"; do
            image_name="${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_PREFIX }}:${service}-${{ needs.build-and-push.outputs.image-tag }}"
            echo "V√©rification de l'image: ${image_name}"
            
            # V√©rifier si l'image existe sur Docker Hub
            if docker manifest inspect "${image_name}" > /dev/null 2>&1; then
              echo "‚úÖ Image ${service} disponible"
            else
              echo "‚ùå Image ${service} non disponible"
              exit 1
            fi
          done
          
          echo "üéâ Toutes les images sont disponibles!"

  # Job 3: Tests d'int√©gration (optionnel)
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup test environment
        run: |
          echo "REGISTRY=${{ env.REGISTRY }}" >> .env
          echo "IMAGE_OWNER=${{ secrets.DOCKERHUB_USERNAME }}" >> .env
          echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" >> .env
          echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}" >> .env

      - name: üöÄ Start services for testing
        run: |
          echo "üöÄ D√©marrage des services pour les tests..."
          
          # Installer curl pour les health checks
          sudo apt-get update && sudo apt-get install -y curl
          
          # D√©marrer d'abord les services d'infrastructure
          docker compose up -d zookeeper kafka auth-postgres catalog-postgres questionnaire-postgres
          
          # Attendre que les services d'infrastructure soient pr√™ts
          echo "‚è≥ Attente que les services d'infrastructure soient pr√™ts..."
          sleep 45
          
          # V√©rifier que Kafka est pr√™t
          echo "üîç V√©rification de Kafka..."
          timeout 60s bash -c 'until docker exec kafka kafka-topics --bootstrap-server localhost:9092 --list >/dev/null 2>&1; do echo "Attente de Kafka..."; sleep 5; done'
          
          # D√©marrer les microservices un par un avec des d√©lais
          echo "üöÄ D√©marrage d'auth-service..."
          docker compose up -d auth-service
          sleep 30
          
          echo "üöÄ D√©marrage de catalog-service..."
          docker compose up -d catalog-service
          sleep 20
          
          echo "üöÄ D√©marrage de questionnaire-service..."
          docker compose up -d questionnaire-service
          sleep 20
          
          echo "üöÄ D√©marrage de statistics-service..."
          docker compose up -d statistics-service
          sleep 20
          
          echo "üöÄ D√©marrage d'api-gateway..."
          docker compose up -d api-gateway
          sleep 30
          
          # Afficher les logs pour diagnostic
          echo "üìã Status des containers:"
          docker compose ps
          
          echo "üìã Logs d'api-gateway:"
          docker compose logs --tail=20 api-gateway

      - name: üß™ Run health checks
        run: |
          echo "üß™ Ex√©cution des v√©rifications de sant√©..."
          
          # Fonction pour v√©rifier la sant√© d'un service
          check_health() {
            local service_name=$1
            local port=$2
            local endpoint=${3:-"/health"}
            local max_attempts=15
            local attempt=1
            
            echo "V√©rification de la sant√© de $service_name sur le port $port..."
            
            while [ $attempt -le $max_attempts ]; do
              echo "‚è≥ Tentative $attempt/$max_attempts pour $service_name..."
              
              # V√©rifier d'abord si le port est ouvert
              if nc -z localhost $port 2>/dev/null; then
                echo "‚úÖ Port $port ouvert pour $service_name"
                
                # Ensuite v√©rifier l'endpoint de sant√©
                if curl -f -s --max-time 10 "http://localhost:$port$endpoint" > /dev/null 2>&1; then
                  echo "‚úÖ $service_name est op√©rationnel"
                  return 0
                else
                  echo "‚ö†Ô∏è Port ouvert mais endpoint de sant√© non accessible pour $service_name"
                fi
              else
                echo "‚ö†Ô∏è Port $port ferm√© pour $service_name"
              fi
              
              sleep 15
              attempt=$((attempt + 1))
            done
            
            echo "‚ùå $service_name n'est pas op√©rationnel apr√®s $max_attempts tentatives"
            
            # Afficher les logs pour diagnostic
            echo "üìã Logs de $service_name:"
            docker compose logs --tail=30 $(echo $service_name | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')
            
            return 1
          }
          
          # Installer netcat pour les v√©rifications de port
          sudo apt-get install -y netcat-traditional
          
          # V√©rifier tous les services dans l'ordre de d√©pendance
          # Note: Les ports correspondent maintenant √† votre docker-compose.yml
          check_health "Auth Service" 5001 "/health" || exit 1
          check_health "Catalog Service" 5003 "/health" || exit 1
          check_health "Questionnaire Service" 5004 "/health" || exit 1
          check_health "Statistics Service" 5005 "/health" || exit 1
          check_health "API Gateway" 5000 "/health" || exit 1
          
          echo "üéâ Tous les services sont op√©rationnels!"

      - name: üß™ Run basic API tests
        run: |
          echo "üß™ Tests basiques des APIs..."
          
          # Test simple de l'API Gateway
          echo "Testing API Gateway basic connectivity..."
          curl -f -s --max-time 10 "http://localhost:5000/health" || {
            echo "‚ùå API Gateway health check failed"
            exit 1
          }
          
          echo "‚úÖ Tests basiques pass√©s!"

      - name: üßπ Cleanup
        if: always()
        run: |
          echo "üßπ Nettoyage..."
          docker compose down -v --remove-orphans
          docker system prune -f

  # Job 4: Notification de succ√®s
  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose, integration-test]
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
      - name: üéâ Success notification
        run: |
          echo "üéâ Pipeline CI/CD termin√© avec succ√®s!"
          echo "üì¶ Images Docker pouss√©es avec le tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "üîó Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}"
          
          echo "üìã Images disponibles:"
          services=("auth-service" "catalog-service" "questionnaire-service" "statistics-service" "api-gateway")
          for service in "${services[@]}"; do
            echo "  - ${service}: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}:${service}-${{ needs.build-and-push.outputs.image-tag }}"
          done

  # Job 5: Nettoyage en cas d'√©chec
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose, integration-test]
    if: failure()
    
    steps:
      - name: üßπ Cleanup failed images
        continue-on-error: true
        run: |
          echo "üßπ Nettoyage des images en cas d'√©chec..."
          # Nettoyer les containers et images
          docker system prune -f --volumes
          echo "‚úÖ Nettoyage termin√©"
