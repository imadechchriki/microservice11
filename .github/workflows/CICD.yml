name: Perfect CI/CD Pipeline

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: docker.io
  IMAGE_OWNER: ${{ secrets.DOCKERHUB_USERNAME }}
  IMAGE_PREFIX: microservice11

jobs:
  # Job 1: Build et Push des images
  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.image-tag }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: auth-service
            context: backend/authentication_system/authentication_system
            dockerfile: Dockerfile
          - name: catalog-service
            context: backend/catalog-service
            dockerfile: Dockerfile
          - name: questionnaire-service
            context: backend/questionnaire-service
            dockerfile: Dockerfile
          - name: statistics-service
            context: backend/statistics-service/Statistics.API
            dockerfile: Dockerfile
          - name: api-gateway
            context: backend/api-gateway
            dockerfile: Dockerfile
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ·ï¸ Generate metadata
        id: meta
        run: |
          # GÃ©nÃ©rer un tag basÃ© sur le SHA court pour une meilleure lisibilitÃ©
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          IMAGE_TAG="${SHORT_SHA}"
          
          # Si c'est une PR, ajouter le numÃ©ro de PR
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            IMAGE_TAG="pr-${{ github.event.number }}-${SHORT_SHA}"
          fi
          
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "short-sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          
          # GÃ©nÃ©rer les tags complets
          FULL_IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}"
          echo "image-name=${FULL_IMAGE_NAME}" >> $GITHUB_OUTPUT

      - name: ğŸ”§ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ğŸ” Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: ğŸ” Verify Dockerfile exists
        run: |
          if [[ ! -f "${{ matrix.context }}/${{ matrix.dockerfile }}" ]]; then
            echo "âŒ Dockerfile not found: ${{ matrix.context }}/${{ matrix.dockerfile }}"
            exit 1
          fi
          echo "âœ… Dockerfile found: ${{ matrix.context }}/${{ matrix.dockerfile }}"

      - name: ğŸ—ï¸ Build and push ${{ matrix.name }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.context }}/${{ matrix.dockerfile }}
          push: true
          platforms: linux/amd64,linux/arm64
          tags: |
            ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-latest
            ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          labels: |
            org.opencontainers.image.title=${{ matrix.name }}
            org.opencontainers.image.description=Microservice ${{ matrix.name }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          cache-from: type=registry,ref=${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-cache
          cache-to: type=registry,ref=${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-cache,mode=max

      - name: ğŸ” Verify image was pushed
        run: |
          echo "ğŸ” VÃ©rification de l'image poussÃ©e..."
          docker pull ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          docker inspect ${{ steps.meta.outputs.image-name }}:${{ matrix.name }}-${{ steps.meta.outputs.image-tag }}
          echo "âœ… Image ${{ matrix.name }} vÃ©rifiÃ©e avec succÃ¨s!"

  # Job 2: Validation de la configuration Docker Compose
  validate-compose:
    name: Validate Docker Compose
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup environment variables
        run: |
          echo "REGISTRY=${{ env.REGISTRY }}" >> .env
          echo "IMAGE_OWNER=${{ secrets.DOCKERHUB_USERNAME }}" >> .env
          echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" >> .env
          echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}" >> .env
          
          echo "ğŸ“‹ Configuration gÃ©nÃ©rÃ©e:"
          cat .env

      - name: âœ… Validate docker-compose configuration
        run: |
          echo "ğŸ” Validation de la configuration docker-compose..."
          docker compose config --quiet
          echo "âœ… Configuration docker-compose validÃ©e!"

      - name: ğŸ” Check image availability
        run: |
          echo "ğŸ” VÃ©rification de la disponibilitÃ© des images..."
          
          services=("auth-service" "catalog-service" "questionnaire-service" "statistics-service" "api-gateway")
          
          for service in "${services[@]}"; do
            image_name="${{ env.REGISTRY }}/${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_PREFIX }}:${service}-${{ needs.build-and-push.outputs.image-tag }}"
            echo "VÃ©rification de l'image: ${image_name}"
            
            # VÃ©rifier si l'image existe sur Docker Hub
            if docker manifest inspect "${image_name}" > /dev/null 2>&1; then
              echo "âœ… Image ${service} disponible"
            else
              echo "âŒ Image ${service} non disponible"
              exit 1
            fi
          done
          
          echo "ğŸ‰ Toutes les images sont disponibles!"

  # Job 3: Tests d'intÃ©gration (optionnel)
  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose]
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ğŸ”§ Setup test environment
        run: |
          echo "REGISTRY=${{ env.REGISTRY }}" >> .env
          echo "IMAGE_OWNER=${{ secrets.DOCKERHUB_USERNAME }}" >> .env
          echo "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" >> .env
          echo "IMAGE_TAG=${{ needs.build-and-push.outputs.image-tag }}" >> .env

      - name: ğŸš€ Start services for testing
        run: |
          echo "ğŸš€ DÃ©marrage des services pour les tests..."
          # DÃ©marrer uniquement les services essentiels pour les tests
          docker compose up -d zookeeper kafka auth-postgres catalog-postgres questionnaire-postgres
          
          # Attendre que les services soient prÃªts
          echo "â³ Attente que les services soient prÃªts..."
          sleep 30
          
          # DÃ©marrer les microservices
          docker compose up -d auth-service catalog-service questionnaire-service statistics-service api-gateway
          
          # Attendre que tous les services soient opÃ©rationnels
          echo "â³ Attente que tous les services soient opÃ©rationnels..."
          sleep 60

      - name: ğŸ§ª Run health checks
        run: |
          echo "ğŸ§ª ExÃ©cution des vÃ©rifications de santÃ©..."
          
          # Fonction pour vÃ©rifier la santÃ© d'un service
          check_health() {
            local service_name=$1
            local port=$2
            local endpoint=${3:-"/health"}
            local max_attempts=10
            local attempt=1
            
            echo "VÃ©rification de la santÃ© de $service_name..."
            
            while [ $attempt -le $max_attempts ]; do
              if curl -f -s "http://localhost:$port$endpoint" > /dev/null 2>&1; then
                echo "âœ… $service_name est opÃ©rationnel"
                return 0
              fi
              
              echo "â³ Tentative $attempt/$max_attempts pour $service_name..."
              sleep 10
              attempt=$((attempt + 1))
            done
            
            echo "âŒ $service_name n'est pas opÃ©rationnel aprÃ¨s $max_attempts tentatives"
            return 1
          }
          
          # VÃ©rifier tous les services
          check_health "API Gateway" 5000 "/health" || exit 1
          check_health "Auth Service" 5001 "/health" || exit 1
          check_health "Catalog Service" 5003 "/health" || exit 1
          check_health "Questionnaire Service" 5004 "/health" || exit 1
          check_health "Statistics Service" 5005 "/health" || exit 1
          
          echo "ğŸ‰ Tous les services sont opÃ©rationnels!"

      - name: ğŸ§¹ Cleanup
        if: always()
        run: |
          echo "ğŸ§¹ Nettoyage..."
          docker compose down -v
          docker system prune -f

  # Job 4: Notification de succÃ¨s
  notify-success:
    name: Notify Success
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose, integration-test]
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/master'
    
    steps:
      - name: ğŸ‰ Success notification
        run: |
          echo "ğŸ‰ Pipeline CI/CD terminÃ© avec succÃ¨s!"
          echo "ğŸ“¦ Images Docker poussÃ©es avec le tag: ${{ needs.build-and-push.outputs.image-tag }}"
          echo "ğŸ”— Registry: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}"
          
          echo "ğŸ“‹ Images disponibles:"
          services=("auth-service" "catalog-service" "questionnaire-service" "statistics-service" "api-gateway")
          for service in "${services[@]}"; do
            echo "  - ${service}: ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_PREFIX }}:${service}-${{ needs.build-and-push.outputs.image-tag }}"
          done

  # Job 5: Nettoyage en cas d'Ã©chec
  cleanup-on-failure:
    name: Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, validate-compose, integration-test]
    if: failure()
    
    steps:
      - name: ğŸ§¹ Cleanup failed images
        continue-on-error: true
        run: |
          echo "ğŸ§¹ Nettoyage des images en cas d'Ã©chec..."
          # Ici vous pourriez ajouter une logique pour supprimer les images partiellement poussÃ©es
          # En fonction de votre stratÃ©gie de gestion des Ã©checs
